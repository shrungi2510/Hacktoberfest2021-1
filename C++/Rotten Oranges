/*
link - https://leetcode.com/problems/rotting-oranges/
Given a grid of dimension nxm where each cell in 
the grid can have values 0, 1 or 2 which has the 
following meaning:
0 : Empty cell
1 : Cells have fresh oranges
2 : Cells have rotten oranges

We have to determine what is the minimum time 
required to rot all oranges. A rotten orange at 
index [i,j] can rot other fresh orange at 
indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] 
(up, down, left and right) in unit time.

Example : 
Input: grid = {{0,1,2},{0,1,2},{2,1,1}}
Output: 1
Explanation: The grid is-
0 1 2
0 1 2
2 1 1
Oranges at positions (0,2), (1,2), (2,0)
will rot oranges at (0,1), (1,1), (2,2) and 
(2,1) in unit time.

Approach :
Count all the oranges (rotten + fresh) 
create an queue all rooten mango.
run a loop till the queue isn't empty
in each iteration we pop the item anc check if we can rotten it.
if yes then enqueue it again.
Also a time frame is maintained which incremented in each iteration.
And along with that number of rottening oranged are counted.
If the initial count and rotten oranges count matches then
we return time or else -1 
*/

#include<bits/stdc++.h>
using namespace std;

struct node{
        int x,y,time;
        node(int xx, int yy, int t){
            x = xx;
            y = yy;
            time = t;
        }
    };
    
int rottenOrange(vector<vector<int>>& grid) {
        // Code here
        int n = grid.size();
        int m = grid[0].size();
        int ans = 0,cnt = 0,cntOranges=0;
        queue<tuple<int,int,int>> q;
        for(int i =0;i<n;++i)
        {
            for(int j = 0;j<m;++j)
            {
                if(grid[i][j]==2)
                {
                    q.push(make_tuple(i,j,0));
                }
                if(grid[i][j]!=0)
                {
                    cntOranges++;
                }
            }
        }
        
        while(!q.empty())
        {
            tuple<int,int,int> t = q.front();
            int x = get<0>(t);
            int y = get<1>(t);
            int tm = get<2>(t);
            
            q.pop();
            cnt++;
            ans = max(ans,tm);
            
            int dx[] = {-1,+1,0,0};
            int dy[] = {0,0,-1,+1};
            
            for(int i =0;i<4;++i)
            {
                
                int newx = x+dx[i];
                int newy = y+dy[i];
                
                if(newx>=0 && newx<n && newy>=0 && newy<m && grid[newx][newy]==1)
                {
                    grid[newx][newy] = 2;
                    q.push(make_tuple(newx,newy,tm+1));
                }
            }
        }
        if(cnt==cntOranges)
        {
            return ans;
        }
        return -1;
}
int main(){
	int n,m;
	cin>>n>>m;
	vector<vector<int>> v(n, vector<int>(m,-1));
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			cin>>v[i][j];
		}
	}
	

	int ans  = rottenOrange(v);
	cout<<ans<<endl;
}
